"""Unit tests for the Axe report generated by axe-selenium-python."""

import io
import json
import zipfile
from datetime import datetime, timezone

from tests.source_collectors.source_collector_test_case import SourceCollectorTestCase

from collector_utilities.functions import md5_hash


class AxeSeleniumPythonTestCase(SourceCollectorTestCase):
    """Base class for testing axe-selenium-python collectors."""

    def setUp(self):
        super().setUp()
        self.axe_json_url = "https://axe.json"
        self.sources = dict(source_id=dict(type="axe_selenium_python", parameters=dict(url=self.axe_json_url)))


class AxeSeleniumPythonAccessibilityTest(AxeSeleniumPythonTestCase):
    """Unit tests for the axe-selenium-python collector for accessibility violations."""

    def setUp(self):
        super().setUp()
        self.tested_url = "https://tested_url"
        self.json = dict(
            url=self.tested_url,
            violations=[
                dict(id="aria-input-field-name", description="description1", helpUrl="https://help1",
                     nodes=[dict(impact="serious", html="html1")]),
                dict(id="aria-hidden-focus", description="description2", helpUrl="https://help2",
                     nodes=[dict(impact="moderate", html="html2")])])
        self.metric = dict(type="accessibility", addition="sum", sources=self.sources)
        self.expected_entities = [
            {
                'description': 'description1',
                'element': 'html1',
                'help': 'https://help1',
                'impact': 'serious',
                'page': self.tested_url,
                'url': self.tested_url,
                'violation_type': 'aria-input-field-name'
            },
            {
                'description': 'description2',
                'element': 'html2',
                'help': 'https://help2',
                'impact': 'moderate',
                'page': self.tested_url,
                'url': self.tested_url,
                'violation_type': 'aria-hidden-focus'
            }]
        for entity in self.expected_entities:
            entity["key"] = md5_hash(",".join(str(value) for value in entity.values()))

    async def test_nr_of_issues(self):
        """Test that the number of issues is returned."""
        response = await self.collect(self.metric, get_request_json_return_value=self.json)
        self.assert_measurement(response, value="2", entities=self.expected_entities)

    async def test_no_issues(self):
        """Test zero issues."""
        self.json["violations"] = []
        response = await self.collect(self.metric, get_request_json_return_value=self.json)
        self.assert_measurement(response, value="0", entities=[])

    async def test_filter_by_impact(self):
        """Test that violations can be filtered by impact level."""
        self.sources["source_id"]["parameters"]["impact"] = ["serious", "critical"]
        response = await self.collect(self.metric, get_request_json_return_value=self.json)
        self.assert_measurement(response, value="1")

    async def test_zipped_json(self):
        """Test that a zip archive with JSON files is processed correctly."""
        self.sources["source_id"]["parameters"]["url"] = f"{self.axe_json_url}.zip"
        bytes_io = io.BytesIO()
        with zipfile.ZipFile(bytes_io, mode="w") as zipped_axe_json:
            for index in range(2):
                zipped_axe_json.writestr(f"axe{index}.json", json.dumps(self.json))
        response = await self.collect(self.metric, get_request_content=bytes_io.getvalue())
        self.assert_measurement(response, value="4", entities=self.expected_entities + self.expected_entities)


class AxeSeleniumPythonSourceUpToDatenessTest(AxeSeleniumPythonTestCase):
    """Unit tests for the source up to dateness metric."""

    async def test_source_up_to_dateness(self):
        """Test that the source age in days is returned."""
        metric = dict(type="source_up_to_dateness", sources=self.sources, addition="max")
        axe_json = dict(timestamp="2020-09-01T14:07:09.445Z")
        response = await self.collect(metric, get_request_json_return_value=axe_json)
        expected_age = (datetime.now(tz=timezone.utc) - datetime(2020, 9, 1, 14, 6, 9, tzinfo=timezone.utc)).days
        self.assert_measurement(response, value=str(expected_age))
